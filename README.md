# bth_work
final work
# Pickle Stability Test Suite

This project investigates the stability and correctness of Python's `pickle` module. The primary goal is to determine if the same Python object, when pickled, always produces an identical byte stream (hash-identical output) under various conditions[cite: 5, 6, 7].

## File Descriptions

* **`final_work.py`**:
    * This is the main script for generating pickled representations of various Python objects and their corresponding SHA256 hashes[cite: 19].
    * It tests a wide range of data types, container types, complex nested structures, recursive objects, custom objects, and fuzzed inputs[cite: 19].
    * The script iterates through different pickle protocols (0 through `pickle.HIGHEST_PROTOCOL`, plus the default protocol for the Python version being used)[cite: 19].
    * Output is saved to a JSON file, which includes the test case ID, a description, the input object's representation (`input_repr`), and a dictionary of hashes for each tested protocol[cite: 19].

* **`compair.py`**:
    * A utility script to compare two JSON output files generated by `final_work.py`[cite: 19].
    * It highlights mismatches in hashes for the same test case ID and protocol between the two files, helping to identify instabilities across different environments or Python versions[cite: 19].

* **`pickle_hashes_py<Version>_<OS>_seed42.json` (e.g., `pickle_hashes_py311_win32_seed42.json`)**:
    * These JSON files are the direct output of `final_work.py` when run in specific environments (Python version and Operating System)[cite: 19].
    * They contain the SHA256 hashes for all test cases across all tested pickle protocols for that particular environment.
    * **Note**: The `pickle_hashes_*.json` files included in this repository were generated using the *updated* version of `final_work.py` (which includes `input_repr`).

* **`input.json`**:
    * This file serves as an **example** of the detailed JSON output structure produced by the *modified* `final_work.py` script. It includes the `input_repr` field, showing the string representation of the input data that was pickled.

* **`report_output.txt`**:
    * This text file contains the comparison results (output from `compair.py`) generated using JSON files from the *original* version of `final_work.py` (the version used when the accompanying PDF report was written). This version of `final_work.py` did *not* output the `input_repr` field.

* **`after_report_modify_output.txt`**:
    * This text file contains comparison results generated using JSON files from the *updated* version of `final_work.py` (which *does* output the `input_repr` field). These are the comparisons corresponding to the `pickle_hashes_*.json` files currently in the repository[cite: 19, 178].

---

## ⚠️ Important Note on Code Modification and Output Discrepancies

The `final_work.py` script was modified *after* the initial project report (the PDF document) was finalized. The primary modification was to add the `input_repr` field to the JSON output generated by `final_work.py`[cite: 19]. This field provides a string representation of the input object, which is helpful for debugging and understanding the exact data that led to a particular hash.

**Why the Post-Report Modification?**

During the report writing phase, it became apparent that having a direct representation of the input object within the results would significantly aid in analyzing any observed discrepancies. The original script focused solely on generating and comparing hashes. The addition of `input_repr` was an enhancement for better traceability and future analysis.

**Discrepancies Between Report and Current Files:**

* The `pickle_hashes_*.json` files in this repository, and consequently the `after_report_modify_output.txt` comparison, were generated using this *updated* `final_work.py`.
* The `report_output.txt` was generated using results from the *original* script, which was used for the findings presented in the PDF report.

You will notice **minor differences** in the hash values reported in `report_output.txt` versus those in `after_report_modify_output.txt` (and by extension, the current `pickle_hashes_*.json` files) for some test cases, even when comparing the same Python versions and OS.

**Reason for these Micro-Discrepancies:**

While the core test data and pickling logic for that data were not intentionally changed, the act of modifying the `final_work.py` script (e.g., adding helper functions like `get_limited_repr`, changing how test cases are structured or iterated internally before being passed to the pickling function) can subtly influence the Python interpreter's internal state or the precise memory layout/representation of objects *before* they are pickled. For certain complex or order-sensitive types (like sets or dictionaries in older Python versions, or even custom objects whose `__repr__` might have side effects if inadvertently called during the data structuring phase), these subtle internal variations can lead to different byte streams upon pickling, and thus different hashes. The project aims to test `pickle` on *identical* inputs[cite: 6, 7, 9]; internal script changes, even if seemingly benign, can sometimes break this strict "identical input" assumption at a very low level for some edge cases.

**Why Not Use the Modified Script's Output for the Original Report?**

The modifications to include `input_repr` were made after the report was already written and findings were documented based on the original script's outputs. Due to time constraints, it was not feasible to regenerate all results across all tested environments and then rewrite portions of the report based on the new outputs. The primary conclusions of the report regarding pickle stability across different *major* Python versions (e.g., 3.6 vs. 3.11) and protocols remain directionally consistent. The enhanced output is provided for more detailed future investigation.

---

## How to Use

1.  **Generate Hashes**:
    * Run `final_work.py` in the desired Python environment (e.g., different Python versions, different operating systems).
    * `python final_work.py`
    * This will produce a JSON file named `pickle_hashes_py<Version>_<OS>_seed<SeedValue>.json` (e.g., `pickle_hashes_py311_win32_seed42.json`) and a more detailed `pickle_inputs_and_hashes_py<Version>_<OS>_seed<SeedValue>.json`.

2.  **Compare Hashes**:
    * Once you have at least two JSON output files (from `final_work.py` using the `pickle_hashes_...` naming) from different environments, you can compare them using `compair.py`.
    * `python compair.py <file1.json> <file2.json>`
    * Example: `python compair.py pickle_hashes_py36_win32_seed42.json pickle_hashes_py311_win32_seed42.json`
    * The script will print any categories, test case IDs, and protocols where hash mismatches or missing entries are found.

---

## Summary of Key Findings from Output Comparisons

The comparison scripts (`report_output.txt` and `after_report_modify_output.txt`) reveal several points about pickle stability:

### 1. Python Version Differences (e.g., Python 3.6 win32 vs. Python 3.11 win32)

* **Default Protocol Changes**: `pickle.DEFAULT_PROTOCOL` is different between Python 3.6 (protocol 3) and Python 3.11 (protocol 4). This naturally leads to different hashes when "Default_Protocol" is compared, as they are not pickling with the same protocol version[cite: 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 39, 40, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 198, 199, 201, 202, 203, 204, 205, 206, 208, 209, 210, 211, 212, 213, 217, 218, 219, 220, 221, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 297, 298, 299].
* **Protocol 0 (Text-based, legacy)**: Often shows mismatches even for simple types like integers and basic structures when comparing Python 3.6 and Python 3.11[cite: 36, 37, 39, 40, 47, 48, 50, 52, 53, 60, 61, 62, 63, 71, 72, 73, 81, 82, 88, 89, 91, 92, 97, 101, 103, 104, 110, 115, 120, 128, 133, 178, 180, 185, 193, 195, 196, 198, 199, 206, 207, 209, 211, 212, 219, 220, 221, 222, 224, 230, 231, 232, 240, 241, 247, 248, 250, 251, 256, 260, 262, 263, 269, 271, 279, 284, 292, 297].
* **Protocol 4**: Shows mismatches for some basic types (e.g., boolean, None, int_zero, int_simple, list_empty, dict_empty, tuple_empty) and more complex types (e.g., sets, fuzzing test cases) between Python 3.6 and 3.11[cite: 38, 41, 42, 57, 59, 69, 70, 78, 79, 80, 85, 96, 100, 108, 112, 113, 119, 124, 126, 182, 183, 197, 200, 201, 216, 218, 228, 229, 237, 238, 239, 244, 255, 257, 259, 267, 275, 276, 277, 283, 288, 290].
* **Protocol 5**: Not available in Python 3.6, so comparisons naturally show it as "MISSING" for the Python 3.6 results[cite: 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299].

### 2. OS Differences (e.g., Python 3.11 darwin vs. Python 3.11 win32)

* **Sets and Frozensets**: Test cases like `frozenset_simple` and `set_simple` show mismatches across all protocols[cite: 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 306, 307, 308, 309, 310, 311, 312, 313]. This is often due to the inherent unordered nature of these types; the iteration order (and thus pickling order) of their elements can vary between OS or even runs, if not explicitly controlled (e.g., by sorting before pickling, as done in `MyObjectStable`).
* **Custom Objects with Sets**: `custom_obj_unstable_no_getstate_with_set_attr`, which contains a set attribute without a custom `__getstate__` to sort it, shows mismatches across all protocols[cite: 146, 147, 148, 149, 314, 315, 316, 317].
* **Fuzzing**: Several fuzzed test cases, particularly those involving sets or complex nested structures, also exhibit OS-dependent hash differences (e.g., `fuzz_3`, `fuzz_17`, `fuzz_21`, `fuzz_25`)[cite: 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338]. The `set_containing_tuples_with_nans` test case also shows OS-based differences[cite: 301, 302, 303, 304, 305].

These findings indicate that while many basic Python objects and structures pickle consistently with a *specific protocol on a specific Python version and OS*, achieving hash-identical pickled output *across different Python versions or operating systems* is not guaranteed, especially for:
* Different pickle protocol versions.
* Data types with inherent ordering ambiguities (like sets and, in older Python versions, dictionaries) if their iteration order isn't explicitly managed before pickling.
* Potentially subtle internal interpreter or C implementation differences between Python versions or OS builds affecting object representation.

# Pickle 稳定性测试套件

本项目旨在研究 Python `pickle` 模块的稳定性和正确性。主要目标是确定同一个 Python 对象在不同条件下进行 pickle 操作时，是否总是能产生完全相同的字节流（即哈希值相同的输出）。

## 文件说明

* **`final_work.py`**:
    * 这是用于生成各种 Python 对象的 pickle 序列化表示及其对应 SHA256 哈希值的主要脚本。
    * 它测试了广泛的数据类型、容器类型、复杂的嵌套结构、递归对象、自定义对象以及模糊测试生成的输入。
    * 该脚本会遍历不同的 pickle 协议（从 0 到 `pickle.HIGHEST_PROTOCOL`，外加当前 Python 版本的默认协议）。
    * 输出保存为一个 JSON 文件，其中包含测试用例 ID、描述、输入对象的表示（`input_repr`）以及针对每种测试协议的哈希值字典。

* **`compair.py`**:
    * 一个工具脚本，用于比较由 `final_work.py` 生成的两个 JSON 输出文件。
    * 它会高亮显示两个文件之间，在相同测试用例 ID 和相同协议下哈希值的差异，有助于识别跨不同环境或 Python 版本的稳定性问题。

* **`pickle_hashes_py<版本号>_<操作系统>_seed42.json` (例如 `pickle_hashes_py311_win32_seed42.json`)**:
    * 这些 JSON 文件是 `final_work.py` 在特定环境（Python 版本和操作系统）下运行的直接输出结果。
    * 它们包含了该特定环境下，所有测试用例在所有测试过的 pickle 协议下的 SHA256 哈希值。
    * **请注意**：本仓库中包含的 `pickle_hashes_*.json` 文件是使用*更新后*的 `final_work.py` 版本（该版本包含了 `input_repr`）生成的。

* **`input.json`**:
    * 此文件作为*修改后*的 `final_work.py` 脚本生成的详细 JSON 输出结构的**示例**。它包含了 `input_repr` 字段，显示了被 pickle 的输入数据的字符串表示。

* **`report_output.txt`**:
    * 此文本文件包含使用*原始版本* `final_work.py`（即撰写配套 PDF 报告时使用的版本）生成的 JSON 文件进行比较的结果（`compair.py` 的输出）。该版本的 `final_work.py` *没有*输出 `input_repr` 字段。 [cite: 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300]

* **`after_report_modify_output.txt`**:
    * 此文本文件包含使用*更新后*的 `final_work.py`（该版本*会*输出 `input_repr` 字段）生成的 JSON 文件进行比较的结果。这些比较结果对应于当前仓库中的 `pickle_hashes_*.json` 文件。 [cite: 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177]

---

## ⚠️ 关于代码修改和输出差异的重要说明

`final_work.py` 脚本在初始项目报告（PDF 文档）定稿*之后*进行了修改。主要修改是在 `final_work.py` 生成的 JSON 输出中添加 `input_repr` 字段。该字段提供了输入对象的字符串表示，有助于调试和理解导致特定哈希值的确切数据。

**为何在报告提交后进行修改？**

在报告撰写阶段，我们意识到在结果中直接包含输入对象的表示形式将极大地有助于分析任何观察到的差异。原始脚本仅专注于生成和比较哈希值。添加 `input_repr` 是为了增强可追溯性和未来的分析。

**报告与当前文件之间的差异：**

* 本仓库中的 `pickle_hashes_*.json` 文件以及因此产生的 `after_report_modify_output.txt` 比较结果，都是使用这个*更新后*的 `final_work.py` 生成的。 [cite: 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136]
* `report_output.txt` 是使用*原始*脚本的输出来生成的，该输出被用于 PDF 报告中的结论。 [cite: 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300]

你会注意到，即使在比较相同的 Python 版本和操作系统时，`report_output.txt` 中报告的哈希值与 `after_report_modify_output.txt`（以及当前 `pickle_hashes_*.json` 文件）中的哈希值在某些测试用例上存在**微小差异**。

**产生这些微小差异的原因：**

尽管核心测试数据及其 pickle 逻辑没有被刻意更改，但修改 `final_work.py` 脚本本身的行为（例如，添加像 `get_limited_repr` 这样的辅助函数，或在传递给 pickle 函数之前更改测试用例的内部结构化或迭代方式）可能会微妙地影响 Python 解释器的内部状态或对象在被 pickle *之前*的精确内存布局/表示。对于某些复杂或对顺序敏感的类型（如旧版本 Python 中的集合或字典，甚至其 `__repr__` 方法如果被无意中调用可能产生副作用的自定义对象），这些细微的内部变化可能导致 pickle 后产生不同的字节流，从而产生不同的哈希值。该项目旨在测试 `pickle` 在*完全相同*的输入上的表现；即使是看似无关紧要的内部脚本更改，有时也可能在非常低的层面上破坏某些边缘情况下“完全相同输入”的严格假设。

**为什么没有使用修改后脚本的输出重新撰写原始报告？**

包含 `input_repr` 的修改是在报告已经撰写完成并且基于原始脚本输出记录了研究结果之后进行的。由于时间限制，重新生成所有环境下所有测试结果，并基于新的输出重写报告的部分内容是不可行的。报告中关于 `pickle` 在不同*主要* Python 版本（例如 3.6 vs 3.11）和协议之间的稳定性的主要结论在方向上仍然是一致的。提供增强后的输出是为了将来进行更详细的调查。

---

## 如何使用

1.  **生成哈希值**:
    * 在目标 Python 环境中运行 `final_work.py`（例如，不同的 Python 版本、不同的操作系统）。
    * `python final_work.py`
    * 这将生成一个名为 `pickle_hashes_py<版本号>_<操作系统>_seed<种子值>.json`（例如 `pickle_hashes_py311_win32_seed42.json`）的 JSON 文件，以及一个更详细的 `pickle_inputs_and_hashes_py<版本号>_<操作系统>_seed<种子值>.json` 文件。

2.  **比较哈希值**:
    * 一旦你拥有至少两个来自不同环境的 JSON 输出文件（由 `final_work.py` 生成，且命名格式为 `pickle_hashes_...`），你就可以使用 `compair.py` 来比较它们。
    * `python compair.py <file1.json> <file2.json>`
    * 示例: `python compair.py pickle_hashes_py36_win32_seed42.json pickle_hashes_py311_win32_seed42.json`
    * 该脚本将打印出哈希值不匹配或条目缺失的类别、测试用例 ID 和协议。

---

## 输出比较的主要发现摘要

比较脚本的输出（`report_output.txt` 和 `after_report_modify_output.txt`）揭示了关于 pickle 稳定性的几个要点：

### 1. Python 版本差异 (例如 Python 3.6 win32 vs Python 3.11 win32)

* **默认协议更改**: Python 3.6 (`pickle.DEFAULT_PROTOCOL` 为 3) 和 Python 3.11 (协议 4) 之间的 `pickle.DEFAULT_PROTOCOL` 是不同的。 [cite: 19, 178] 这自然会导致在比较 "Default_Protocol" 时哈希值不同，因为它们使用的不是相同的协议版本。
* **协议 0 (文本格式，旧版)**: 在比较 Python 3.6 和 Python 3.11 时，即使对于简单的类型（如整数）和基本结构，也经常显示不匹配。 [cite: 36, 37, 39, 40, 195, 196, 198, 199]
* **协议 4**: 对于某些基本类型（例如布尔型 [cite: 23, 24, 182, 183]、None [cite: 42, 201]、int_zero [cite: 41, 200]、int_simple [cite: 38, 197]、空的 list [cite: 70, 229]、空的 dict [cite: 59, 218]、空的 tuple [cite: 87, 246]）以及更复杂的类型（例如集合 [cite: 85, 244]、模糊测试用例 [cite: 97, 98, 100, 101, 103, 110, 112, 113, 126, 256, 257, 259, 260, 262, 269, 276, 277, 290]）在 Python 3.6 和 3.11 之间显示不匹配。
* **协议 5**: 在 Python 3.6 中不可用，因此在比较时，Python 3.6 的结果自然会显示为 "MISSING"。 [cite: 19, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135]

### 2. 操作系统差异 (例如 Python 3.11 darwin vs Python 3.11 win32)

* **集合 (Set) 和不可变集合 (Frozenset)**: 像 `frozenset_simple` 和 `set_simple` 这样的测试用例在所有协议中都显示了跨操作系统的差异。 [cite: 137, 138, 139, 140, 141, 142, 143, 144, 145] 这通常是由于这些类型固有的无序性造成的；它们的元素迭代顺序（从而影响 pickle 序列化顺序）可能因操作系统甚至运行次数而异，除非在 pickle 之前显式控制（例如，像 `MyObjectStable` 中那样进行排序）。
* **包含集合的自定义对象**: `custom_obj_unstable_no_getstate_with_set_attr` 包含一个集合属性，但没有自定义 `__getstate__` 来对其排序，因此在所有协议中都显示出差异。 [cite: 146, 147, 148, 149]
* **模糊测试**: 一些模糊测试用例，特别是涉及集合或复杂嵌套结构的用例，也表现出依赖于操作系统的哈希差异（例如 `fuzz_3`[cite: 171, 172, 173, 174, 175, 176, 177], `fuzz_17`[cite: 150, 151, 152, 153, 154, 155, 156], `fuzz_21`[cite: 157, 158, 159, 160, 161, 162, 163], `fuzz_25` [cite: 164, 165, 166, 167, 168, 169, 170]）。`set_containing_tuples_with_nans` 测试用例也显示了基于操作系统的差异。 [cite: 301, 302, 303, 304, 305]

这些发现表明，尽管许多基本的 Python 对象和结构在*特定 Python 版本和操作系统上使用特定协议*进行 pickle 时表现出一致性，但并*不能保证*在*不同 Python 版本或操作系统之间*获得哈希值完全相同的 pickle 输出，尤其是在以下情况：
* 使用不同的 pickle 协议版本。
* 对于具有固有顺序模糊性的数据类型（如集合，以及旧版 Python 中的字典），如果在 pickle 前没有明确管理其迭代顺序。
* Python 版本或操作系统构建版本之间可能存在细微的内部解释器或 C 实现差异，从而影响对象表示。
